# DTOs (Data Transfer Objects)

DTOs are classes that model the structure of data being transferred between the application and a remote source, such as a Supabase database table or a REST API endpoint. They are responsible for serialization and deserialization.

## 1. File Naming and Location

-   **Location**: `lib/<feature>/dtos/<dto_name>_dto.dart`
-   **Naming**: The file is named in `snake_case` and ends with `_dto.dart`. The class name is the `PascalCase` version.

**Example:** `lib/auth/dtos/user_profile_dto.dart`

## 2. Structure and Conventions

-   **Serialization**:
    -   DTO classes are annotated with `@JsonSerializable()`.
    -   This requires a corresponding `part '<dto_name>_dto.g.dart';` directive. The `.g.dart` file is generated by `build_runner`.
    -   `fieldRename: FieldRename.snake` is often used to automatically convert Dart's `camelCase` fields to `snake_case` for JSON keys, which is common in databases.
-   **Base Class/Interface**: DTOs that map to Supabase tables should implement the `SupabaseDto` abstract class, which enforces the presence of `id`, `createdAt`, and `updatedAt` fields.
-   **Immutability**: All properties of a DTO should be `final`.
-   **Constructors and Factories**:
    -   A `const` constructor is used to create instances.
    -   **IMPORTANT**: All fields should be `required` in the constructor, even nullable fields. This ensures explicit handling of null values.
    -   A `factory YourDto.fromJson(Map<String, dynamic> json)` is required for `json_serializable` and is used to create an instance from a JSON map. It delegates to the generated `_$YourDtoFromJson` function.
-   **`toJson()` Method**:
    -   An instance method `Map<String, dynamic> toJson()` is required for `json_serializable` to convert the DTO instance into a JSON map. It delegates to the generated `_$YourDtoToJson` function.
-   **`copyWith()` Method**:
    -   A `copyWith` method is included to allow for the creation of a new, modified instance from an existing one, which is useful for immutability.
    -   For nullable fields that need to be explicitly set to null, use a boolean `force` parameter pattern (e.g., `bool forceFieldName = false`).
    -   Example: `fieldName: forceFieldName ? fieldName : fieldName ?? this.fieldName`

## 3. Example

```dart
// lib/auth/dtos/user_profile_dto.dart

import 'package:{project_name}/core/dto/supabase_dto.dart';
import 'package:json_annotation/json_annotation.dart';

part 'user_profile_dto.g.dart';

@JsonSerializable()
class UserProfileDto implements SupabaseDto {
  const UserProfileDto({
    required this.id,
    required this.updatedAt,
    required this.createdAt,
    required this.username, // nullable but still required
    // ... other final properties
  });

  @override
  final String id;
  @override
  final DateTime updatedAt;
  @override
  final DateTime createdAt;
  final String? username;

  // Serialization methods
  factory UserProfileDto.fromJson(Map<String, dynamic> json) => _$UserProfileDtoFromJson(json);
  @override
  Map<String, dynamic> toJson() => _$UserProfileDtoToJson(this);

  // copyWith method
  UserProfileDto copyWith({
    String? id,
    DateTime? updatedAt,
    DateTime? createdAt,
    String? username,
    bool forceUsername = false, // force pattern for nullable fields
  }) {
    return UserProfileDto(
      id: id ?? this.id,
      updatedAt: updatedAt ?? this.updatedAt,
      createdAt: createdAt ?? this.createdAt,
      username: forceUsername ? username : username ?? this.username,
    );
  }
}
```
